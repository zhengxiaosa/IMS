2019-03-08

**数据库相关规范**
-----



**设计规范**
-----

>所有的表和字段添加备注说明comments

>所有的表名和字段名小写,数据库,数据表一律使用前缀

>必须把字段定义为NOT NULL（非空）并且提供默认值

>注意数据类型选取和长度设定问题，如：tinyint,smallint, mediumint,int,bigint，若非逻辑需求则整形字段都使用无符号整形。

>需要进行数据操作（CURD）的表，尽量都添加 status(tinyint(1))，create_time(datetime)，update_time(datetime) 字段。

>所有表的主键自增列都使用id作为字段名称

>必须使用InnoDB存储引擎。

>必须使用utf8mb4字符集

>表中的status字段为数据状态，尽量不要与业务逻辑混合，如支付状态可新增 pay_status字段记录

>临时表必须以tmp_为前缀并以日期为后缀

>备份表必须以bak_为前缀并以日期为后缀

>所有存储相同数据的列名和列类型必须一致，比如user表中的id和order表中的user_id

>所有数据库对象名称禁止使用mysql保留关键字

>数据库对象的命名要能做到见名知意，并且最好不要超过32个字符。太长不方便使用，并且会在传输时增加网络开销

>尽量做到冷热数据分离，减少表的宽度(字段数) 

>禁止在表中建立预留字段 

>禁止从开发环境，测试环境直连生产环境数据库

>禁止使用存储过程、视图、触发器、Event

>禁止使用数据库外键约束


**索引设计规范**
-----

>单表索引建议控制在5个以内

>单索引字段数不允许超过5个

>禁止在更新十分频繁、区分度不高的属性上建立索引

>建立组合索引，必须把区分度高的字段放在前面

>不要使用uuid，md5，hash，字符串列作为主键

>每个Innodb表都必须有一个主键 关联中间表使用MyIsam


**开发规范**
-----

* 建议使用预编译语句(prepareStatment)进行数据库操作 

    >可以同步执行预编译计划，减少预编译时间

    >可以有效避免动态sql带来的SQL注入的问题

    >只传参数，一次解析，多次使用，比传递sql语句更高效

* 避免数据类型的隐式转换 

    >一般出现在where从句中，会导致索引失效，如：select id,name from user where id = ‘12’;
    
* 充分利用已存在的索引 


	>避免使用双%的查询条件，不走索引

	>一个SQL只能利用到复合索引中的一列进行范围查询

	>使用left join或not exists来优化not in操作

* 程序连接不同的数据库使用不同的账号，禁止跨库查询 

	>为数据库迁移和分库分表留出余地

	>降低业务耦合度

	>避免权限过大而产生的安全风险

* 禁止使用select * 来查询，必须用字段名 

	>可能会消耗更多的cpu和IO以及网络资源
	>无法使用覆盖索引

	>可以减少表结构变更对已有程序的影响

* 禁止使用不含字段列表的insert语句。 


	>可以减少表结构变更对已有程序的影响

* 禁止使用子查询 

	>虽然可使sql可读性好，但是缺点远远大于优点

	>子查询返回的结果集无法使用索引，结果集会被存储到一个临时表中，结果集越大性能越低

	>把子查询优化为join操作，但是并不是所有的都可以优化为join，一般情况下，只有当子查询是在in字句中，并且子查询是一个简单的sql(不包含union，group by，order by，limit)才能转换为关联查询

* 避免join过多的表 

	>每join一个表会占一部分内存(join_buffer_size)

	>会产生临时表操作，影响查询效率

	>mysql最多允许关联61个表，建议不超过5个

* 减少同数据库的交互次数 

	>数据库更适合处理批量操作

	>合并多个相同的操作到一起，提高处理效率

* 使用in代替or 

	>in的值不要超过500个

	>in 操作可以有效利用索引

* 禁止使用order by rand()进行随机排序 

	>会把表中所有符合条件的数据装载到内存中进行排序

	>会消耗大量的cpu和io及内存资源

	>推荐在程序中获取随机值

* 禁止在where从句中对列进行函数转换和计算 

	>导致无法使用相关列上的索引

	>where date(create_time)=’20170901’ 写成 where create_time >= ‘20170901’ and create_time < ‘20170902’

* 在明显不会有重复值时使用union all而不是union 

	>union 会把所有数据放在临时表中后再进行去重操作，会多消耗内存，IO，网络资源

	>union all 不会再对结果集进行去重操作

* 拆分复杂的大sql为多个小sql 

	>目前mysql中一个sql只能使用一个cpu计算，不支持多cpu并行计算

	>sql拆分后可以通过并行执行来提高处理效率




